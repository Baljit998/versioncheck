this is half of api.py in api folder
import frappe
import os
from frappe.utils.nestedset import rebuild_tree, get_ancestors_of
from pypika import Order, Field, functions as fn
from pathlib import Path
from werkzeug.wrappers import Response
from werkzeug.wsgi import wrap_file
from werkzeug.utils import secure_filename
import uuid
import mimetypes
import hashlib
import json
from drive.utils.files import (
    get_user_directory,
    create_user_directory,
    get_new_title,
    get_user_thumbnails_directory,
    create_user_thumbnails_directory,
    create_thumbnail,
)
from drive.locks.distributed_lock import DistributedLock
from datetime import date, timedelta
import magic


def if_folder_exists(folder_name, parent):
    values = {
        "title": folder_name,
        "is_group": 1,
        "is_active": 1,
        "owner": frappe.session.user,
        "parent_drive_entity": parent,
    }
    existing_folder = frappe.db.get_value(
        "Drive Entity", values, ["name", "title", "is_group", "is_active"], as_dict=1
    )
    if existing_folder:
        return existing_folder.name
    new_folder = create_folder(folder_name, parent)
    return new_folder.name


@frappe.whitelist()
def get_home_folder_id(user=None):
    """Returns user directory name from user's unique id"""
    if not user:
        user = frappe.session.user
        return get_user_directory(user).name


@frappe.whitelist()
def create_document_entity(title, content, parent=None):
    try:
        user_directory = get_user_directory()
    except FileNotFoundError:
        user_directory = create_user_directory()
    new_title = get_new_title(title, parent)

    parent = frappe.form_dict.parent or user_directory.name

    if not frappe.has_permission(
        doctype="Drive Entity",
        doc=parent,
        ptype="write",
        user=frappe.session.user,
    ):
        frappe.throw(
            "Cannot access folder due to insufficient permissions",
            frappe.PermissionError,
        )
    drive_doc = frappe.new_doc("Drive Document")
    drive_doc.title = new_title
    drive_doc.content = content
    drive_doc.save()

    drive_entity = frappe.new_doc("Drive Entity")
    drive_entity.title = new_title
    drive_entity.name = uuid.uuid4().hex
    drive_entity.parent_drive_entity = parent
    drive_entity.mime_type = "frappe_doc"
    drive_entity.document = drive_doc

    drive_entity.flags.file_created = True
    drive_entity.save()
    return drive_entity


@frappe.whitelist()
def upload_file(fullpath=None, parent=None):
    """
    Accept chunked file contents via a multipart upload, store the file on
    disk, and insert a corresponding DriveEntity doc.

    :param fullpath: Full path of the uploaded file
    :param parent: Document-name of the parent folder. Defaults to the user directory
    :raises PermissionError: If the user does not have write access to the specified parent folder
    :raises FileExistsError: If a file with the same name already exists in the specified parent folder
    :raises ValueError: If the size of the stored file does not match the specified filesize
    :return: DriveEntity doc once the entire file has been uploaded
    """
    try:
        user_directory = get_user_directory()
    except FileNotFoundError:
        user_directory = create_user_directory()

    parent = frappe.form_dict.parent or user_directory.name

    if fullpath:
        dirname = os.path.dirname(fullpath).split("/")
        for i in dirname:
            parent = if_folder_exists(i, parent)

    if not frappe.has_permission(
        doctype="Drive Entity", doc=parent, ptype="write", user=frappe.session.user
    ):
        frappe.throw("Cannot upload due to insufficient permissions", frappe.PermissionError)

    file = frappe.request.files["file"]
    title = get_new_title(file.filename, parent)

    current_chunk = int(frappe.form_dict.chunk_index)
    total_chunks = int(frappe.form_dict.total_chunk_count)

    save_path = Path(user_directory.path) / f"{parent}_{secure_filename(title)}"

    if current_chunk == 0 and save_path.exists():
        frappe.throw(f"File '{title}' already exists", FileExistsError)

    with save_path.open("ab") as f:
        f.seek(int(frappe.form_dict.chunk_byte_offset))
        f.write(file.stream.read())

    if current_chunk + 1 == total_chunks:
        file_size = save_path.stat().st_size
        if file_size != int(frappe.form_dict.total_file_size):
            save_path.unlink()
            frappe.throw("Size on disk does not match specified filesize", ValueError)

        mime_type, _ = mimetypes.guess_type(save_path)

        if mime_type is None:
            # Read the first 2KB of the binary stream to determine the file type if string checking failed
            # Do a rejection workflow to reject undesired mime types
            mime_type = magic.from_buffer(open(save_path, "rb").read(2048), mime=True)

        file_name, file_ext = os.path.splitext(title)
        name = uuid.uuid4().hex
        path = save_path.parent / f"{name}{save_path.suffix}"
        save_path.rename(path)

        drive_entity = create_drive_entity(
            name, title, parent, path, file_size, file_ext, mime_type
        )

        if mime_type.startswith(("image", "video")):
            frappe.enqueue(
                create_thumbnail,
                queue="default",
                timeout=None,
                now=True,
                at_front=True,
                # will set to false once reactivity in new UI is solved
                entity_name=name,
                path=path,
                mime_type=mime_type,
            )
        return drive_entity


def create_drive_entity(name, title, parent, path, file_size, file_ext, mime_type):
    drive_entity = frappe.get_doc(
        {
            "doctype": "Drive Entity",
            "name": name,
            "title": title,
            "parent_drive_entity": parent,
            "path": path,
            "file_size": file_size,
            "file_ext": file_ext,
            "mime_type": mime_type,
        }
    )
    drive_entity.flags.file_created = True
    drive_entity.insert()
    return drive_entity


@frappe.whitelist()
def create_folder(title, parent=None):
    """
    Create a new folder.

    :param title: Folder name
    :param parent: Document-name of the parent folder. Defaults to the user directory
    :raises PermissionError: If the user does not have write access to the specified parent folder
    :raises FileExistsError: If a folder with the same name already exists in the specified parent folder
    :return: DriveEntity doc of the new folder
    """

    try:
        user_directory = get_user_directory()
    except FileNotFoundError:
        user_directory = create_user_directory()

    parent = parent or user_directory.name
    if not frappe.has_permission(
        doctype="Drive Entity", doc=parent, ptype="write", user=frappe.session.user
    ):
        frappe.throw(
            "Cannot create folder due to insufficient permissions",
            frappe.PermissionError,
        )

    entity_exists = frappe.db.exists(
        {"doctype": "Drive Entity", "parent_drive_entity": parent, "title": title}
    )
    if entity_exists:
        suggested_name = get_new_title(title, parent)
        frappe.throw(
            f"Folder '{title}' already exists.\n Suggested: {suggested_name}",
            FileExistsError,
        )

    drive_entity = frappe.get_doc(
        {
            "doctype": "Drive Entity",
            "name": uuid.uuid4().hex,
            "title": title,
            "is_group": 1,
            "parent_drive_entity": parent,
            "color": "#525252",
        }
    )
    drive_entity.insert()

    return drive_entity


def get_doc_content(drive_document_name):
    drive_document = frappe.db.get_value(
        "Drive Document",
        drive_document_name,
        ["content"],
        as_dict=1,
    )
    return drive_document


""" @frappe.whitelist()
def rename_doc_entity(entity_name, title):
    doc_name = frappe.db.get_value("Drive Entity", entity_name, "document")
    frappe.db.set_value("Drive Document", doc_name, "title", title)
    frappe.db.set_value("Drive Entity", entity_name, "title", title)
    return """


@frappe.whitelist()
def save_doc(entity_name, doc_name, content, file_size):
    if not frappe.has_permission(
        doctype="Drive Entity",
        doc=entity_name,
        ptype="write",
        user=frappe.session.user,
    ):
        raise frappe.PermissionError("You do not have permission to view this file")
    drive_document = frappe.db.set_value("Drive Document", doc_name, "content", content)
    frappe.db.set_value("Drive Entity", entity_name, "file_size", file_size)
    return


@frappe.whitelist(allow_guest=True)
def get_file_content(entity_name, trigger_download=0):
    """
    Stream file content and optionally trigger download

    :param entity_name: Document-name of the file whose content is to be streamed
    :param trigger_download: 1 to trigger the "Save As" dialog. Defaults to 0
    :type trigger_download: int
    :raises ValueError: If the DriveEntity doc does not exist or is not a file
    :raises PermissionError: If the current user does not have permission to read the file
    :raises FileLockedError: If the file has been writer-locked
    """

    is_public = False
    if frappe.db.exists(
        {
            "doctype": "Drive DocShare",
            "share_doctype": "Drive Entity",
            "share_name": entity_name,
            "public": 1,
        }
    ):
        is_public = True
    if not is_public:
        if not frappe.has_permission(
            doctype="Drive Entity",
            doc=entity_name,
            ptype="read",
            user=frappe.session.user,
        ):
            raise frappe.PermissionError("You do not have permission to view this file")
    trigger_download = int(trigger_download)
    drive_entity = frappe.get_value(
        "Drive Entity",
        entity_name,
        ["is_group", "path", "title", "mime_type", "file_size"],
        as_dict=1,
    )
    if not drive_entity or drive_entity.is_group:
        raise ValueError

    with DistributedLock(drive_entity.path, exclusive=False):
        range_header = frappe.request.headers.get("Range")
        # if range_header is not None:
        # h = range_header.replace("bytes=", "").split("-")
        # print (h)
        # start = int(h[0]) if h[0] != "" else 0
        # end = int(h[1]) if h[1] != "" else file_size - 1
        # start, end = get_range_header(range_header, file_size)
        # size = end - start + 1
        # print (size)
        # response.headers.add("Content-Range", f"bytes {start}-{end}/{drive_entity.file_size}")
        # status_code = status.HTTP_206_PARTIAL_CONTENT
        # Figure out a sane way to handle blob range streaming requests

        try:
            file = open(drive_entity.path, "rb")
        except TypeError:
            response = Response(frappe.request.environ)
            response.status_code = 204
            return response

        response = Response(wrap_file(frappe.request.environ, file), direct_passthrough=True)
        response.mimetype = drive_entity.mime_type or "application/octet-stream"
        content_dispostion = "attachment" if trigger_download else "inline"
        response.headers.add(
            "Content-Disposition",
            content_dispostion,
            filename=drive_entity.title.encode("utf-8"),
        )
        response.headers.add("Content-Length", str(drive_entity.file_size))
        response.headers.add("Content-Type", response.mimetype)
        response.headers.add("Accept-Range", "bytes")
        return response


@frappe.whitelist(allow_guest=True)
def list_folder_contents(entity_name=None, order_by="modified", is_active=1):
    """
    Return list of DriveEntity records present in this folder

    :param entity_name: Document-name of the folder whose contents are to be listed. Defaults to the user directory
    :param order_by: Sort the list of results according to the specified field (eg: 'modified desc'). Defaults to 'title'
    :raises NotADirectoryError: If this DriveEntity doc is not a folder
    :raises PermissionError: If the user does not have access to the specified folder
    :return: List of DriveEntity records
    :rtype: list
    """

    try:
        entity_name = entity_name or get_user_directory().name
    except FileNotFoundError:
        return []
    parent_is_group, parent_is_active = frappe.db.get_value(
        "Drive Entity", entity_name, ["is_group", "is_active"]
    )
    if not parent_is_group:
        frappe.throw("Specified entity is not a folder", NotADirectoryError)
    if not parent_is_active:
        frappe.throw("Specified folder has been trashed by the owner")
    is_public = False
    if frappe.db.exists(
        {
            "doctype": "Drive DocShare",
            "share_doctype": "Drive Entity",
            "share_name": entity_name,
            "public": 1,
        }
    ):
        is_public = True
    if not is_public:
        if not frappe.has_permission(
            doctype="Drive Entity",
            doc=entity_name,
            ptype="read",
            user=frappe.session.user,
        ):
            frappe.throw(
                "Cannot access folder due to insufficient permissions",
                frappe.PermissionError,
            )
    general_access_val = "public" if is_public else "everyone"
    DriveEntity = frappe.qb.DocType("Drive Entity")
    DriveFavourite = frappe.qb.DocType("Drive Favourite")
    DriveDocShare = frappe.qb.DocType("Drive DocShare")
    DriveUser = frappe.qb.DocType("User")
    UserGroupMember = frappe.qb.DocType("User Group Member")
    selectedFields = [
        DriveEntity.name,
        DriveEntity.title,
        DriveEntity.is_group,
        DriveEntity.owner,
        DriveUser.full_name,
        DriveUser.user_image,
        DriveEntity.modified,
        DriveEntity.creation,
        DriveEntity.file_size,
        DriveEntity.file_ext,
        DriveEntity.color,
        DriveEntity.document,
        DriveEntity.mime_type,
        DriveEntity.parent_drive_entity,
        DriveEntity.allow_download,
        DriveEntity.is_active,
        DriveEntity.allow_comments,
        DriveDocShare.read,
        DriveDocShare.user_name,
        fn.Max(DriveDocShare.write).as_("write"),
        DriveDocShare.public,
        DriveDocShare.everyone,
        DriveDocShare.share,
        DriveFavourite.entity.as_("is_favourite"),
    ]

    query = (
        frappe.qb.from_(DriveEntity)
        .inner_join(DriveDocShare)
        .on((DriveDocShare.share_name == DriveEntity.name))
        .left_join(UserGroupMember)
        .on((UserGroupMember.parent == DriveDocShare.user_name))
        .left_join(DriveFavourite)
        .on(
            (DriveFavourite.entity == DriveEntity.name)
            & (DriveFavourite.user == frappe.session.user)
        )
        .left_join(DriveUser)
        .on((DriveEntity.owner == DriveUser.email))
        .select(*selectedFields)
        .where(
            (DriveEntity.parent_drive_entity == entity_name)
            & (DriveEntity.is_active == 1)
            & (
                (UserGroupMember.user == frappe.session.user)
                | (
                    (DriveDocShare.user_name == frappe.session.user)
                    | (DriveDocShare[general_access_val] == 1)
                )
            )
        )
        .groupby(DriveEntity.name)
        .orderby(
            order_by.split()[0],
            order=Order.desc if order_by.endswith("desc") else Order.asc,
        )
    )
    result = query.run(as_dict=True)
    return result


@frappe.whitelist()
def list_owned_entities(entity_name=None, order_by="modified", is_active=1):
    """
    Return list of DriveEntity records present in this folder

    :param entity_name: Document-name of the folder whose contents are to be listed. Defaults to the user directory
    :param order_by: Sort the list of results according to the specified field (eg: 'modified desc'). Defaults to 'title'
    :raises NotADirectoryError: If this DriveEntity doc is not a folder
    :raises PermissionError: If the user does not have access to the specified folder
    :return: List of DriveEntity records
    :rtype: list
    """

    try:
        entity_name = entity_name or get_user_directory().name
    except FileNotFoundError:
        return []
    parent_is_group, parent_is_active, parent_owner = frappe.db.get_value(
        "Drive Entity", entity_name, ["is_group", "is_active", "owner"]
    )
    if not parent_is_group:
        frappe.throw("Specified entity is not a folder", NotADirectoryError)
    if not parent_is_active:
        frappe.throw("Specified folder has been trashed by the owner")
    if not frappe.session.user == parent_owner:
        frappe.throw("Not permitted")
    if not frappe.has_permission(
        doctype="Drive Entity", doc=entity_name, ptype="write", user=frappe.session.user
    ):
        frappe.throw(
            "Not permitted to read",
            frappe.PermissionError,
        )

    # entity_ancestors = get_ancestors_of("Drive Entity", entity_name)
    # flag = False
    # for z_entity_name in entity_ancestors:
    #    result = frappe.db.exists("Drive Entity", {"name": z_entity_name, "is_active": 0})
    #    if result:
    #        flag = True
    #        break
ChatGPT

It looks like you've shared a portion of Python code from a Frappe app, specifically related to the Frappe Drive functionality. This code appears to define various API endpoints and functions for managing files and folders within the Frappe Drive.

Here's a brief overview of the code:

    Imports:
        The code imports necessary modules and libraries, including Frappe utilities, file handling tools, and external libraries like pypika, mimetypes, magic, and others.

    Folder and Document Creation:
        Functions like create_folder and create_document_entity handle the creation of folders and documents within the Frappe Drive.

    File Upload:
        The upload_file function manages the uploading of files, handling chunked file uploads and ensuring permissions are checked.

    File Content Retrieval:
        Functions like get_file_content and list_folder_contents handle the retrieval of file content and listing folder contents, respectively. They also ensure proper permissions are in place.

    Dependency on External Libraries:
        The code relies on external libraries like magic for determining file MIME types and pypika for building SQL queries.

    Error Handling:
        The code includes error handling to manage various scenarios, such as insufficient permissions, file existence checks, and others.

Please note that this is a partial view of the code, and the functionality of the entire Frappe Drive system is distributed across multiple files and modules. If you have specific questions about certain functions or parts of the code, feel free to ask for clarification!
User
this is other half
#        break
    # if flag == True:
    #    frappe.throw("Parent Folder has been deleted")
    DriveEntity = frappe.qb.DocType("Drive Entity")
    DriveUser = frappe.qb.DocType("User")
    DriveFavourite = frappe.qb.DocType("Drive Favourite")
    selectedFields = [
        DriveEntity.name,
        DriveEntity.title,
        DriveEntity.is_group,
        DriveEntity.owner,
        DriveUser.full_name,
        DriveUser.user_image,
        DriveEntity.modified,
        DriveEntity.creation,
        DriveEntity.file_size,
        DriveEntity.file_ext,
        DriveEntity.color,
        DriveEntity.document,
        DriveEntity.mime_type,
        DriveEntity.parent_drive_entity,
        DriveEntity.allow_download,
        DriveEntity.allow_comments,
        DriveFavourite.entity.as_("is_favourite"),
    ]

    query = (
        frappe.qb.from_(DriveEntity)
        .left_join(DriveFavourite)
        .on(
            (DriveFavourite.entity == DriveEntity.name)
            & (DriveFavourite.user == frappe.session.user)
        )
        .left_join(DriveUser)
        .on((DriveEntity.owner == DriveUser.email))
        .select(*selectedFields)
        .where(
            (DriveEntity.parent_drive_entity == entity_name) & (DriveEntity.is_active == is_active)
        )
        .groupby(DriveEntity.name)
        .orderby(
            order_by.split()[0],
            order=Order.desc if order_by.endswith("desc") else Order.asc,
        )
    )
    result = query.run(as_dict=True)
    for i in result:
        if i.is_group:
            child_count = get_children_count(i.name)
            i["item_count"] = child_count
    return result


@frappe.whitelist()
def get_trashed_entities(order_by="modified", is_active=1):
    return frappe.db.get_all(
        "Drive Entity",
        filters={"is_active": 0, "owner": ["like", frappe.session.user]},
        fields=[
            "name",
            "title",
            "is_group",
            "owner",
            "modified",
            "creation",
            "file_size",
            "file_ext",
            "color",
            "document",
            "mime_type",
        ],
    )


def get_entity(entity_name, fields=None):
    """
    Return specific entity

    :param entity_name: Document-name of the file or folder
    :raises PermissionError: If the user does not have access to the specified entity
    :rtype: frappe._dict
    """
    fields = fields or ["name", "title", "owner"]
    return frappe.db.get_value("Drive Entity", entity_name, fields, as_dict=1)


@frappe.whitelist()
def get_entities_in_path(entity_name, fields=None, shared=False):
    """
    Return list of all DriveEntities present in the path.

    :param entity_name: Document-name of the file or folder
    :param fields: List of doc-fields that should be returned. Defaults to ['name', 'title', 'owner']
    :param shared: True if entity in question has been shared with the user
    :raises PermissionError: If the user does not have access to the specified entity
    :return: List of parents followed by the specified DriveEntity
    :rtype: list[frappe._dict]
    """

    fields = fields or ["name", "title", "owner"]
    rebuild_tree("Drive Entity", "parent_drive_entity")
    if not frappe.has_permission(
        doctype="Drive Entity", doc=entity_name, ptype="read", user=frappe.session.user
    ):
        frappe.throw("Cannot access path due to insufficient permissions", frappe.PermissionError)
    path = get_ancestors_of("Drive Entity", entity_name, "lft asc")
    path.append(entity_name)
    entities = [
        frappe.db.get_value("Drive Entity", entity, fields, as_dict=True) for entity in path
    ]

    if entities[0].owner != frappe.session.user:
        return get_shared_entities_in_path(entities)

    result = {"is_shared": False, "entities": []}
    result["entities"] += entities
    return result


@frappe.whitelist()
def get_shared_entities_in_path(entities):
    """
    Return list of all DriveEntities present in the path for a shared folder.

    :param entities: All entities in path
    :return: List of parents followed by the specified DriveEntity
    :rtype: list[frappe._dict]
    """

    shared_entities = [entities[-1]]
    highest_level_reached = False
    i = -2
    while not highest_level_reached:
        if frappe.db.exists(
            "DocShare", {"user": frappe.session.user, "share_name": entities[i].name}
        ) or frappe.db.exists("DocShare", {"everyone": 1, "share_name": entities[i].name}):
            shared_entities.insert(0, entities[i])
            i -= 1
        else:
            highest_level_reached = True

    result = {"is_shared": True, "entities": []}
    result["entities"] += shared_entities
    return result


@frappe.whitelist(allow_guest=True)
def list_entity_comments(entity_name):
    Comment = frappe.qb.DocType("Comment")
    User = frappe.qb.DocType("User")
    selectedFields = [
        Comment.comment_by,
        Comment.comment_email,
        Comment.creation,
        Comment.content,
        User.user_image,
    ]

    query = (
        frappe.qb.from_(Comment)
        .inner_join(User)
        .on(Comment.comment_email == User.name)
        .select(*selectedFields)
        .where(
            (Comment.comment_type == "Comment")
            & (Comment.reference_doctype == "Drive Entity")
            & (Comment.reference_name == entity_name)
        )
        .orderby(Comment.creation, order=Order.asc)
    )
    return query.run(as_dict=True)


@frappe.whitelist()
def unshare_entities(entity_names, move=False):
    """
    Unshare DriveEntities

    :param entity_names: List of document-names
    :type entity_names: list[str]
    :param move: if True, moves entity to root entity of user
    :type move: Boolean
    :raises ValueError: If decoded entity_names is not a list
    """

    if isinstance(entity_names, str):
        entity_names = json.loads(entity_names)
    if not isinstance(entity_names, list):
        frappe.throw(f"Expected list but got {type(entity_names)}", ValueError)
    for entity in entity_names:
        doc = frappe.get_doc("Drive Entity", entity)
        if not doc:
            frappe.throw("Entity does not exist", ValueError)
        if move:
            doc.move()
        doc.unshare(frappe.session.user)


def delete_background_job(entity, ignore_permissions):
    frappe.delete_doc("Drive Entity", entity, ignore_permissions=ignore_permissions)


@frappe.whitelist()
def delete_entities(entity_names):
    """
    Delete DriveEntities

    :param entity_names: List of document-names
    :type entity_names: list[str]
    :raises ValueError: If decoded entity_names is not a list
    """
    if isinstance(entity_names, str):
        entity_names = json.loads(entity_names)
    if not isinstance(entity_names, list):
        frappe.throw(f"Expected list but got {type(entity_names)}", ValueError)
    for entity in entity_names:
        root_entity = get_ancestors_of("Drive Entity", entity)
        if root_entity:
            root_entity = get_ancestors_of("Drive Entity", entity)[0]
        else:
            root_entity = get_user_directory()
        owns_root_entity = frappe.has_permission(
            doctype="Drive Entity",
            doc=root_entity,
            ptype="write",
            user=frappe.session.user,
        )
        has_write_access = frappe.has_permission(
            doctype="Drive Entity", doc=entity, ptype="write", user=frappe.session.user
        )
        ignore_permissions = owns_root_entity or has_write_access
        frappe.db.set_value("Drive Entity", entity, "is_active", -1)
        frappe.enqueue(
            delete_background_job,
            queue="default",
            timeout=None,
            entity=entity,
            ignore_permissions=ignore_permissions,
        )


@frappe.whitelist()
def list_favourites(order_by="modified"):
    """
    Return list of DriveEntity records present in this folder

    :param order_by: Sort the list of results according to the specified field (eg: 'modified desc'). Defaults to 'title'
    :return: List of DriveEntity records
    :rtype: list
    """

    DriveFavourite = frappe.qb.DocType("Drive Favourite")
    DriveEntity = frappe.qb.DocType("Drive Entity")
    DriveDocShare = frappe.qb.DocType("Drive DocShare")
    DriveUser = frappe.qb.DocType("User")
    UserGroupMember = frappe.qb.DocType("User Group Member")
    selectedFields = [
        DriveEntity.name,
        DriveEntity.title,
        DriveEntity.is_group,
        DriveEntity.owner,
        DriveUser.full_name,
        DriveEntity.owner,
        DriveEntity.modified,
        DriveEntity.creation,
        DriveEntity.file_size,
        DriveEntity.mime_type,
        DriveEntity.color,
        DriveEntity.document,
        DriveEntity.parent_drive_entity,
        DriveEntity.allow_comments,
        DriveDocShare.read,
        fn.Max(DriveDocShare.write).as_("write"),
        DriveDocShare.share,
        DriveDocShare.everyone,
        DriveFavourite.entity.as_("is_favourite"),
    ]
    query = (
        frappe.qb.from_(DriveEntity)
        .right_join(DriveFavourite)
        .on(
            (DriveFavourite.entity == DriveEntity.name)
            & (DriveFavourite.user == frappe.session.user)
        )
        .left_join(DriveDocShare)
        .on((DriveDocShare.share_name == DriveEntity.name))
        .left_join(UserGroupMember)
        .on(
            (
                (UserGroupMember.parent == DriveDocShare.user_name)
                & (UserGroupMember.user == frappe.session.user)
            )
            | (
                (DriveDocShare.user_name == frappe.session.user)
                | ((DriveDocShare.everyone == 1) | (DriveDocShare.public == 1))
            )
        )
        .left_join(DriveUser)
        .on((DriveEntity.owner == DriveUser.email))
        .select(*selectedFields)
        .where(
            (DriveEntity.is_active == 1)
            & ((DriveEntity.owner == frappe.session.user) | (DriveDocShare.read == 1))
        )
        .groupby(DriveEntity.name)
        .orderby(
            order_by.split()[0],
            order=Order.desc if order_by.endswith("desc") else Order.asc,
        )
    )
    return query.run(as_dict=True)


@frappe.whitelist()
def add_or_remove_favourites(entity_names=None, clear_all=False):
    """
    Favouite or unfavourite DriveEntities for specified user

    :param entity_names: List of document-names
    :type entity_names: list[str]
    :raises ValueError: If decoded entity_names is not a list
    """

    if clear_all:
        frappe.db.delete("Drive Favourite", {"user": frappe.session.user})
        return

    if isinstance(entity_names, str):
        entity_names = json.loads(entity_names)
    if not isinstance(entity_names, list):
        frappe.throw(f"Expected list but got {type(entity_names)}", ValueError)
    for entity in entity_names:
        existing_doc = frappe.db.exists(
            {
                "doctype": "Drive Favourite",
                "entity": entity,
                "user": frappe.session.user,
            }
        )
        if existing_doc:
            frappe.delete_doc("Drive Favourite", existing_doc)
        else:
            doc = frappe.get_doc(
                {
                    "doctype": "Drive Favourite",
                    "entity": entity,
                    "user": frappe.session.user,
                }
            )
            doc.insert()


# def toggle_is_active(doc):
#     doc.is_active = 0 if doc.is_active else 1
#     frappe.db.set_value('Drive Entity', doc.name, 'is_active',doc.is_active)
#     for child in doc.get_children():
#         toggle_is_active(child)


@frappe.whitelist()
def remove_or_restore(entity_names, move=False):
    """
    To move entities to or restore entities from the trash

    :param entity_names: List of document-names
    :type entity_names: list[str]
    """
    if isinstance(entity_names, str):
        entity_names = json.loads(entity_names)
    if not isinstance(entity_names, list):
        frappe.throw(f"Expected list but got {type(entity_names)}", ValueError)

    def depth_zero_toggle_is_active(doc):
        doc.is_active = 0 if doc.is_active else 1
        frappe.db.set_value("Drive Entity", doc.name, "is_active", doc.is_active)

    for entity in entity_names:
        doc = frappe.get_doc("Drive Entity", entity)
        if doc.is_active:
            entity_ancestors = get_ancestors_of("Drive Entity", entity)
            if entity_ancestors:
                doc.parent_before_trash = entity_ancestors[0]
            else:
                doc.parent_before_trash = get_user_directory()
            if move:
                doc.move()

        else:
            parent_is_active = frappe.db.get_value(
                "Drive Entity", doc.parent_before_trash, "is_active"
            )
            if parent_is_active:
                doc.move(doc.parent_before_trash)
            else:
                doc.move()
        depth_zero_toggle_is_active(doc)
        # frappe.enqueue(toggle_is_active,queue="default",timeout=None,doc=doc)


@frappe.whitelist()
def call_controller_method(entity_name, method):
    """
    Call a whitelisted Drive Entity controller method

    :param entity_name: Document-name of the document on which the controller method is to be called
    :param method: The controller method to be called
    :raises ValueError: If the entity does not exist
    :return: The result of the controller method
    """

    drive_entity = frappe.get_doc("Drive Entity", frappe.local.form_dict.pop("entity_name"))
    if not drive_entity:
        frappe.throw("Entity does not exist", ValueError)
    method = frappe.local.form_dict.pop("method")
    drive_entity.is_whitelisted(method)
    frappe.local.form_dict.pop("cmd")
    return drive_entity.run_method(method, **frappe.local.form_dict)


@frappe.whitelist()
def list_recents(order_by="last_interaction"):
    """
    Return list of DriveEntity records present in this folder

    :param order_by: Sort the list of results according to the specified field (eg: 'modified desc'). Defaults to 'title'
    :return: List of DriveEntity records
    :rtype: list
    """

    DriveFavourite = frappe.qb.DocType("Drive Favourite")
    DriveEntity = frappe.qb.DocType("Drive Entity")
    DriveDocShare = frappe.qb.DocType("Drive DocShare")
    DriveRecent = frappe.qb.DocType("Drive Entity Log")
    DriveUser = frappe.qb.DocType("User")
    UserGroupMember = frappe.qb.DocType("User Group Member")
    selectedFields = [
        DriveEntity.name,
        DriveEntity.title,
        DriveUser.full_name,
        DriveUser.user_image,
        DriveEntity.owner,
        DriveEntity.is_group,
        DriveEntity.file_size,
        DriveEntity.mime_type,
        DriveEntity.allow_comments,
        DriveEntity.allow_download,
        DriveEntity.creation,
        DriveEntity.document,
        DriveFavourite.entity.as_("is_favourite"),
        DriveDocShare.user_name,
        DriveDocShare.read,
        fn.Max(DriveDocShare.write).as_("write"),
        DriveDocShare.share,
        DriveDocShare.everyone,
        DriveRecent.last_interaction.as_("modified"),
    ]
    query = (
        frappe.qb.from_(DriveRecent)
        .left_join(DriveEntity)
        .on(
            (DriveRecent.entity_name == DriveEntity.name)
            & (DriveRecent.user == frappe.session.user)
        )
        .left_join(DriveFavourite)
        .on(
            (DriveFavourite.entity == DriveEntity.name)
            & (DriveFavourite.user == frappe.session.user)
        )
        .left_join(DriveDocShare)
        .on((DriveDocShare.share_name == DriveEntity.name))
        .left_join(UserGroupMember)
        .on(
            (
                (UserGroupMember.parent == DriveDocShare.user_name)
                & (UserGroupMember.user == frappe.session.user)
            )
            | (
                (DriveDocShare.user_name == frappe.session.user)
                | ((DriveDocShare.everyone == 1) | (DriveDocShare.public == 1))
            )
        )
        .left_join(DriveUser)
        .on((DriveEntity.owner == DriveUser.email))
        .select(*selectedFields)
        .where(
            (DriveEntity.is_active == 1)
            & ((DriveEntity.owner == frappe.session.user) | (DriveDocShare.read == 1))
        )
        .groupby(DriveEntity.name)
        .orderby(DriveRecent.last_interaction, order=Order.desc)
    )
    return query.run(as_dict=True)


@frappe.whitelist()
def remove_recents(entity_names=None, clear_all=False):
    """
    Clear recent DriveEntities for specified user

    :param entity_names: List of document-names
    :type entity_names: list[str]
    :raises ValueError: If decoded entity_names is not a list
    """

    if clear_all:
        frappe.db.delete("Drive Entity Log", {"user": frappe.session.user})
        return
    if isinstance(entity_names, str):
        entity_names = json.loads(entity_names)
    if not isinstance(entity_names, list):
        frappe.throw(f"Expected list but got {type(entity_names)}", ValueError)
    for entity in entity_names:
        existing_doc = frappe.db.exists(
            {
                "doctype": "Drive Entity Log",
                "entity_name": entity,
                "user": frappe.session.user,
            }
        )
        if existing_doc:
            frappe.delete_doc("Drive Entity Log", existing_doc)


@frappe.whitelist()
def get_children_count(drive_entity):
    children_count = frappe.db.count(
        "Drive Entity", {"parent_drive_entity": drive_entity, "is_active": 1}
    )
    return children_count


@frappe.whitelist()
def does_entity_exist(name=None, parent_entity=None):
    result = frappe.db.exists(
        "Drive Entity", {"parent_drive_entity": parent_entity, "title": name}
    )
    return bool(result)


def auto_delete_from_trash():
    days_before = (date.today() - timedelta(days=30)).isoformat()
    result = frappe.db.get_all(
        "Drive Entity",
        filters={"is_active": 0, "trashed_on": ["<", days_before]},
        fields=["name"],
    )
    delete_entities(result)


@frappe.whitelist()
def get_user_directory_size():
    try:
        user_directory = get_user_directory(0)
        cmd = f"du -sh {Path(user_directory.path)} | grep -oP '^[\d.]+[KMG]' "
        result = os.popen(cmd)
        size = result.read().strip()
    except:
        size = "0M"
    return size


@frappe.whitelist()
def toggle_allow_comments(entity_name, new_value):
    """
    Toggle allow comments for entity without updating modified

    """

    frappe.db.set_value(
        "Drive Entity", entity_name, "allow_comments", new_value, update_modified=False
    )
    return


@frappe.whitelist()
def toggle_allow_download(entity_name, new_value):
    """
    Toggle allow download for entity without updating modified

    """

    frappe.db.set_value(
        "Drive Entity", entity_name, "allow_download", new_value, update_modified=False
    )
    return


@frappe.whitelist()
def get_title(entity_name):
    """
    Toggle allow download for entity

    """
    if not frappe.has_permission(
        doctype="Drive Entity", doc=entity_name, ptype="write", user=frappe.session.user
    ):
        frappe.throw("Not permitted", frappe.PermissionError)
    return frappe.db.get_value("Drive Entity", entity_name, "title")
2 / 2
ChatGPT

It looks like you've provided a large piece of Python code related to a Frappe application for managing drive entities. If you have any specific questions or if there's anything specific you'd like assistance with, please let me know, and I'll do my best to help!
User
explain this in detail
ChatGPT

Certainly! The provided Python code appears to be part of a Frappe application for managing drive entities. Let's break down the code into sections to understand its functionality:

    get_drive_entities_in_path Function:

    python

def get_drive_entities_in_path(entity_name, fields=None, order_by="title asc", is_active=1):

    This function retrieves a list of Drive Entities within a specified path.
    entity_name: The document name of the file or folder in question.
    fields: List of document fields to be returned (defaults to None).
    order_by: Sorting order for the result (defaults to "title asc").
    is_active: Filter for active entities (defaults to 1).

Explanation:

    It uses Frappe's Query Builder (frappe.qb) to construct a SQL query for fetching data.
    The query involves multiple joins and conditions to get information about Drive Entities.
    The result includes details like name, title, owner, file size, file extension, etc.
    It also checks if the entity is a group and calculates the item count for groups.

Usage:

    It seems to be used for retrieving information about Drive Entities in a specified path.

get_trashed_entities Function:

python

@frappe.whitelist()
def get_trashed_entities(order_by="modified", is_active=1):

    This function retrieves trashed Drive Entities.
    order_by: Sorting order for the result (defaults to "modified").
    is_active: Filter for active entities (defaults to 1).

Explanation:

    It uses Frappe's frappe.db.get_all to fetch trashed entities based on specified conditions.
    The result includes information like name, title, owner, file size, etc.

Usage:

    It appears to be used for retrieving trashed entities.

get_entity Function:

python

def get_entity(entity_name, fields=None):

    This function returns specific information about a Drive Entity.
    entity_name: The document name of the file or folder.
    fields: List of document fields to be returned (defaults to ["name", "title", "owner"]).

Explanation:

    It uses Frappe's frappe.db.get_value to retrieve specific fields for a given entity.

Usage:

    It seems to be used for getting details about a specific Drive Entity.

get_entities_in_path Function:

python

@frappe.whitelist()
def get_entities_in_path(entity_name, fields=None, shared=False):

    This function returns a list of all Drive Entities present in a given path.
    entity_name: The document name of the file or folder.
    fields: List of document fields to be returned (defaults to ["name", "title", "owner"]).
    shared: Boolean indicating if the entity has been shared with the user.

Explanation:

    It checks permissions, rebuilds the tree, and fetches entities along the specified path.
    If the entity is not owned by the user, it uses get_shared_entities_in_path to handle shared entities.

Usage:

    Used for obtaining a list of entities in a specified path.

get_shared_entities_in_path Function:

python

@frappe.whitelist()
def get_shared_entities_in_path(entities):

    This function returns shared entities present in the path.
    entities: List of entities in the path.

Explanation:

    It iterates through the entities, checking for shared entities using Frappe's frappe.db.exists.
    The result includes shared entities and their hierarchy.

Usage:

    Used within get_entities_in_path for shared entities.

list_entity_comments Function:

python

@frappe.whitelist(allow_guest=True)
def list_entity_comments(entity_name):

    This function lists comments for a specific Drive Entity.
    entity_name: The document name of the Drive Entity.

Explanation:

    It uses Frappe's Query Builder to fetch comments related to the specified entity.

Usage:

    Used for obtaining comments related to a Drive Entity.

unshare_entities Function:

python

@frappe.whitelist()
def unshare_entities(entity_names, move=False):

    This function unshares Drive Entities.
    entity_names: List of document names to be unshared.
    move: Boolean indicating whether to move the entity to the root of the user.

Explanation:

    It uses Frappe's frappe.get_doc and unshare method to unshare entities.
    Can move entities if move is set to True.

Usage:

    Used for unsharing Drive Entities.

delete_background_job Function:

python

def delete_background_job(entity, ignore_permissions):

    This function is enqueued to delete a Drive Entity in the background.
    entity: Document name of the entity to be deleted.
    ignore_permissions: Boolean indicating whether to ignore permissions.

Explanation:

    It uses Frappe's frappe.delete_doc to delete a Drive Entity.

Usage:

    Enqueued to delete entities in the background.

delete_entities Function:

python

    @frappe.whitelist()
    def delete_entities(entity_names):

        This function deletes Drive Entities.
        entity_names: List of document names to be deleted.

    Explanation:
        It uses Frappe's frappe.db.set_value to mark entities as inactive.
        Enqueues delete_background_job to delete entities in the background.

    Usage:
        Used for deleting Drive Entities.

    list_favourites Function:

python

@frappe.whitelist()
def list_favourites(order_by="modified"):

    This function lists favorite Drive Entities.
    order_by: Sorting order for the result (defaults to "modified").

Explanation:

    It constructs a complex query using Frappe's Query Builder to fetch favorite entities.

Usage:

    Used for obtaining a list of favorite Drive Entities.

    add_or_remove_favourites Function:

python

@frappe.whitelist()
def add_or_remove_favourites(entity_names=None, clear_all=False):

    This function adds or removes Drive Entities from favorites.
    entity_names: List of document names to be added or removed.
    clear_all: Boolean indicating whether to clear all favorites.

Explanation:

    It adds or removes entities based on the provided parameters.

Usage:

    Used for managing favorite Drive Entities.

    remove_or_restore Function:

python

@frappe.whitelist()
def remove_or_restore(entity_names, move=False):

    This function removes or restores Drive Entities from the trash.
    entity_names: List of document names to be removed or restored.
    move: Boolean indicating whether to move the entity to its parent before trashing.

Explanation:

    It moves entities back to their parent or restores them from the trash.

Usage:

    Used for removing or restoring Drive Entities from the trash.

    call_controller_method Function:

python

@frappe.whitelist()
def call_controller_method(entity_name, method):

    This function calls a whitelisted Drive Entity controller method.
    entity_name: Document name of the entity on which the controller method is called.
    method: The controller method to be called.

Explanation:

    It uses Frappe's frappe.get_doc to get the Drive Entity and calls the specified method.

Usage:

    Used for calling controller methods on Drive Entities.

    list_recents Function:

python

@frappe.whitelist()
def list_recents(order_by="last_interaction"):

    This function lists recent Drive Entities.
    order_by: Sorting order for the result (defaults to "last_interaction").

Explanation:

    It constructs a query to fetch recent Drive Entities based on interactions.

Usage:

    Used for obtaining a list of recently interacted Drive Entities.

    remove_recents Function:

python

@frappe.whitelist()
def remove_recents(entity_names=None, clear_all=False):

    This function removes recent Drive Entities for a specified user.
    entity_names: List of document names to be removed.
    clear_all: Boolean indicating whether to clear all recent entities.

Explanation:

    It removes recent entities based on the provided parameters.

Usage:

    Used for managing recent Drive Entities.

    get_children_count Function:

python

@frappe.whitelist()
def get_children_count(drive_entity):

    This function returns the count of children for a specified Drive Entity.
    drive_entity: Document name of the Drive Entity.

Explanation:

    It uses Frappe's frappe.db.count to count the children of the specified entity.

Usage:

    Used for getting the count of children for a Drive Entity.

    does_entity_exist Function:

python

@frappe.whitelist()
def does_entity_exist(name=None, parent_entity=None):

    This function checks if a Drive Entity with a specific name exists under a parent entity.
    name: The title of the Drive Entity.
    parent_entity: Document name of the parent entity.

Explanation:

    It uses Frappe's frappe.db.exists to check for the existence of the specified entity.

Usage:

    Used for checking if a Drive Entity with a specific name exists.

    auto_delete_from_trash Function:

python

def auto_delete_from_trash():

    This function automatically deletes entities from the trash that are older than 30 days.

Explanation:

    It fetches trashed entities older than 30 days and enqueues their deletion in the background.

Usage:

    Used for automatically cleaning up trashed entities.

    get_user_directory_size Function:

python

@frappe.whitelist()
def get_user_directory_size():

    This function returns the size of the user's directory.

Explanation:

    It uses the du command to get the size of the user's directory.

Usage:

    Used for obtaining the size of the user's directory.

    toggle_allow_comments Function:

python

@frappe.whitelist()
def toggle_allow_comments(entity_name, new_value):

    This function toggles the "allow comments" property for a Drive Entity.
    entity_name: Document name of the Drive Entity.
    new_value: New value for the "allow comments" property.

Explanation:

    It uses Frappe's frappe.db.set_value to toggle the "allow comments" property without updating the modified timestamp.

Usage:

    Used for toggling the "allow comments" property.

    toggle_allow_download Function:

python

@frappe.whitelist()
def toggle_allow_download(entity_name, new_value):

    This function toggles the "allow download" property for a Drive Entity.
    entity_name: Document name of the Drive Entity.
    new_value: New value for the "allow download" property.

Explanation:

    It uses Frappe's frappe.db.set_value to toggle the "allow download" property without updating the modified timestamp.

Usage:

    Used for toggling the "allow download" property.

    get_title Function:

python

@frappe.whitelist()
def get_title(entity_name):

    This function returns the title of a Drive Entity.
    entity_name: Document name of the Drive Entity.

Explanation:

    It uses Frappe's frappe.db.get_value to retrieve the title of the specified entity.

Usage:

    Used for obtaining the title of a Drive Entity.

These functions collectively provide a comprehensive set of operations for managing Drive Entities, including fetching entity details, managing favorites, trashed entities, recent entities, and more. The code is designed to interact with the Frappe framework, making use of its ORM capabilities and whitelisted functions.
